{"version":3,"file":"index.js","sources":["../src/utils.js","../src/hooks/useTable.js","../src/actions.js","../src/plugin-hooks/useExpanded.js","../src/filterTypes.js","../src/plugin-hooks/useFilters.js","../src/aggregations.js","../src/plugin-hooks/useGroupBy.js","../src/sortTypes.js","../src/plugin-hooks/useSortBy.js","../src/plugin-hooks/usePagination.js","../src/plugin-hooks/useRowSelect.js","../src/plugin-hooks/useRowState.js","../src/plugin-hooks/useColumnOrder.js","../src/plugin-hooks/useResizeColumns.js","../src/plugin-hooks/useAbsoluteLayout.js","../src/plugin-hooks/useBlockLayout.js"],"sourcesContent":["import React from 'react'\n\nexport const defaultColumn = {\n  Cell: ({ cell: { value = '' } }) => String(value),\n  show: true,\n  width: 150,\n  minWidth: 0,\n  maxWidth: Number.MAX_SAFE_INTEGER,\n}\n\n// SSR has issues with useLayoutEffect still, so use useEffect during SSR\nexport const safeUseLayoutEffect =\n  typeof window !== 'undefined' && process.env.NODE_ENV === 'production'\n    ? React.useLayoutEffect\n    : React.useEffect\n\n// Find the depth of the columns\nexport function findMaxDepth(columns, depth = 0) {\n  return columns.reduce((prev, curr) => {\n    if (curr.columns) {\n      return Math.max(prev, findMaxDepth(curr.columns, depth + 1))\n    }\n    return depth\n  }, 0)\n}\n\nexport function decorateColumn(\n  column,\n  userDefaultColumn,\n  parent,\n  depth,\n  index\n) {\n  // Apply the userDefaultColumn\n  column = { ...defaultColumn, ...userDefaultColumn, ...column }\n\n  // First check for string accessor\n  let { id, accessor, Header } = column\n\n  if (typeof accessor === 'string') {\n    id = id || accessor\n    const accessorPath = accessor.split('.')\n    accessor = row => getBy(row, accessorPath)\n  }\n\n  if (!id && typeof Header === 'string' && Header) {\n    id = Header\n  }\n\n  if (!id && column.columns) {\n    console.error(column)\n    throw new Error('A column ID (or unique \"Header\" value) is required!')\n  }\n\n  if (!id) {\n    console.error(column)\n    throw new Error('A column ID (or string accessor) is required!')\n  }\n\n  column = {\n    // Make sure there is a fallback header, just in case\n    Header: () => <>&nbsp;</>,\n    ...column,\n    // Materialize and override this stuff\n    id,\n    accessor,\n    parent,\n    depth,\n    index,\n  }\n\n  return column\n}\n\n// Build the visible columns, headers and flat column list\nexport function decorateColumnTree(columns, defaultColumn, parent, depth = 0) {\n  return columns.map((column, columnIndex) => {\n    column = decorateColumn(column, defaultColumn, parent, depth, columnIndex)\n    if (column.columns) {\n      column.columns = decorateColumnTree(\n        column.columns,\n        defaultColumn,\n        column,\n        depth + 1\n      )\n    }\n    return column\n  })\n}\n\n// Build the header groups from the bottom up\nexport function makeHeaderGroups(flatColumns, defaultColumn) {\n  const headerGroups = []\n\n  // Build each header group from the bottom up\n  const buildGroup = (columns, depth) => {\n    const headerGroup = {\n      headers: [],\n    }\n\n    const parentColumns = []\n\n    // Do any of these columns have parents?\n    const hasParents = columns.some(col => col.parent)\n\n    columns.forEach(column => {\n      // Are we the first column in this group?\n      const isFirst = !parentColumns.length\n\n      // What is the latest (last) parent column?\n      let latestParentColumn = [...parentColumns].reverse()[0]\n\n      // If the column has a parent, add it if necessary\n      if (column.parent) {\n        const similarParentColumns = parentColumns.filter(\n          d => d.originalID === column.parent.id\n        )\n        if (isFirst || latestParentColumn.originalID !== column.parent.id) {\n          parentColumns.push({\n            ...column.parent,\n            originalID: column.parent.id,\n            id: [column.parent.id, similarParentColumns.length].join('_'),\n          })\n        }\n      } else if (hasParents) {\n        // If other columns have parents, we'll need to add a place holder if necessary\n        const originalID = [column.id, 'placeholder'].join('_')\n        const similarParentColumns = parentColumns.filter(\n          d => d.originalID === originalID\n        )\n        const placeholderColumn = decorateColumn(\n          {\n            originalID,\n            id: [column.id, 'placeholder', similarParentColumns.length].join(\n              '_'\n            ),\n            placeholderOf: column,\n          },\n          defaultColumn\n        )\n        if (\n          isFirst ||\n          latestParentColumn.originalID !== placeholderColumn.originalID\n        ) {\n          parentColumns.push(placeholderColumn)\n        }\n      }\n\n      // Establish the new headers[] relationship on the parent\n      if (column.parent || hasParents) {\n        latestParentColumn = [...parentColumns].reverse()[0]\n        latestParentColumn.headers = latestParentColumn.headers || []\n        if (!latestParentColumn.headers.includes(column)) {\n          latestParentColumn.headers.push(column)\n        }\n      }\n\n      column.totalHeaderCount = column.headers\n        ? column.headers.reduce(\n            (sum, header) => sum + header.totalHeaderCount,\n            0\n          )\n        : 1 // Leaf node columns take up at least one count\n      headerGroup.headers.push(column)\n    })\n\n    headerGroups.push(headerGroup)\n\n    if (parentColumns.length) {\n      buildGroup(parentColumns, depth + 1)\n    }\n  }\n\n  buildGroup(flatColumns, 0)\n\n  return headerGroups.reverse()\n}\n\nexport function determineHeaderVisibility(instance) {\n  const { headers } = instance\n\n  const handleColumn = (column, parentVisible) => {\n    column.isVisible = parentVisible\n      ? typeof column.show === 'function'\n        ? column.show(instance)\n        : !!column.show\n      : false\n\n    let totalVisibleHeaderCount = 0\n\n    if (column.headers && column.headers.length) {\n      column.headers.forEach(\n        subColumn =>\n          (totalVisibleHeaderCount += handleColumn(subColumn, column.isVisible))\n      )\n    } else {\n      totalVisibleHeaderCount = column.isVisible ? 1 : 0\n    }\n\n    column.totalVisibleHeaderCount = totalVisibleHeaderCount\n\n    return totalVisibleHeaderCount\n  }\n\n  let totalVisibleHeaderCount = 0\n\n  headers.forEach(\n    subHeader => (totalVisibleHeaderCount += handleColumn(subHeader, true))\n  )\n}\n\nexport function getBy(obj, path, def) {\n  if (!path) {\n    return obj\n  }\n  const pathObj = makePathArray(path)\n  let val\n  try {\n    val = pathObj.reduce((cursor, pathPart) => cursor[pathPart], obj)\n  } catch (e) {\n    // continue regardless of error\n  }\n  return typeof val !== 'undefined' ? val : def\n}\n\nexport function defaultOrderByFn(arr, funcs, dirs) {\n  return [...arr].sort((rowA, rowB) => {\n    for (let i = 0; i < funcs.length; i += 1) {\n      const sortFn = funcs[i]\n      const desc = dirs[i] === false || dirs[i] === 'desc'\n      const sortInt = sortFn(rowA, rowB)\n      if (sortInt !== 0) {\n        return desc ? -sortInt : sortInt\n      }\n    }\n    return dirs[0] ? rowA.index - rowB.index : rowB.index - rowA.index\n  })\n}\n\nexport function getFirstDefined(...args) {\n  for (let i = 0; i < args.length; i += 1) {\n    if (typeof args[i] !== 'undefined') {\n      return args[i]\n    }\n  }\n}\n\nexport function defaultGroupByFn(rows, columnID) {\n  return rows.reduce((prev, row, i) => {\n    // TODO: Might want to implement a key serializer here so\n    // irregular column values can still be grouped if needed?\n    const resKey = `${row.values[columnID]}`\n    prev[resKey] = Array.isArray(prev[resKey]) ? prev[resKey] : []\n    prev[resKey].push(row)\n    return prev\n  }, {})\n}\n\nexport function getElementDimensions(element) {\n  const rect = element.getBoundingClientRect()\n  const style = window.getComputedStyle(element)\n  const margins = {\n    left: parseInt(style.marginLeft),\n    right: parseInt(style.marginRight),\n  }\n  const padding = {\n    left: parseInt(style.paddingLeft),\n    right: parseInt(style.paddingRight),\n  }\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n    outerWidth: Math.ceil(\n      rect.width + margins.left + margins.right + padding.left + padding.right\n    ),\n    marginLeft: margins.left,\n    marginRight: margins.right,\n    paddingLeft: padding.left,\n    paddingRight: padding.right,\n    scrollWidth: element.scrollWidth,\n  }\n}\n\nexport function flexRender(Comp, props) {\n  return isReactComponent(Comp) ? <Comp {...props} /> : Comp\n}\n\nfunction isClassComponent(component) {\n  return (\n    typeof component === 'function' &&\n    !!(() => {\n      let proto = Object.getPrototypeOf(component)\n      return proto.prototype && proto.prototype.isReactComponent\n    })()\n  )\n}\n\nfunction isFunctionComponent(component) {\n  return typeof component === 'function'\n}\n\nfunction isReactComponent(component) {\n  return isClassComponent(component) || isFunctionComponent(component)\n}\n\nexport const mergeProps = (...groups) => {\n  let props = {}\n  groups.forEach(({ style = {}, className, ...rest } = {}) => {\n    props = {\n      ...props,\n      ...rest,\n      style: {\n        ...(props.style || {}),\n        ...style,\n      },\n      className: [props.className, className].filter(Boolean).join(' '),\n    }\n  })\n  return props\n}\n\nexport const applyHooks = (hooks, initial, ...args) =>\n  hooks.reduce((prev, next) => {\n    const nextValue = next(prev, ...args)\n    if (typeof nextValue === 'undefined') {\n      throw new Error(\n        'React Table: A hook just returned undefined! This is not allowed.'\n      )\n    }\n    return nextValue\n  }, initial)\n\nexport const applyPropHooks = (hooks, ...args) =>\n  hooks.reduce((prev, next) => mergeProps(prev, next(...args)), {})\n\nexport const warnUnknownProps = props => {\n  if (Object.keys(props).length) {\n    throw new Error(\n      `Unknown options passed to useReactTable:\n\n${JSON.stringify(props, null, 2)}`\n    )\n  }\n}\n\nexport function sum(arr) {\n  return arr.reduce((prev, curr) => prev + curr, 0)\n}\n\nexport function isFunction(a) {\n  if (typeof a === 'function') {\n    return a\n  }\n}\n\nexport function flattenBy(columns, childKey) {\n  const flatColumns = []\n\n  const recurse = columns => {\n    columns.forEach(d => {\n      if (!d[childKey]) {\n        flatColumns.push(d)\n      } else {\n        recurse(d[childKey])\n      }\n    })\n  }\n\n  recurse(columns)\n\n  return flatColumns\n}\n\nexport function ensurePluginOrder(plugins, befores, pluginName, afters) {\n  const pluginIndex = plugins.findIndex(\n    plugin => plugin.pluginName === pluginName\n  )\n\n  if (pluginIndex === -1) {\n    throw new Error(`The plugin ${pluginName} was not found in the plugin list!\nThis usually means you need to need to name your plugin hook by setting the 'pluginName' property of the hook function, eg:\n\n  ${pluginName}.pluginName = '${pluginName}'\n`)\n  }\n\n  befores.forEach(before => {\n    const beforeIndex = plugins.findIndex(\n      plugin => plugin.pluginName === before\n    )\n    if (beforeIndex > -1 && beforeIndex > pluginIndex) {\n      throw new Error(\n        `React Table: The ${pluginName} plugin hook must be placed after the ${before} plugin hook!`\n      )\n    }\n  })\n\n  afters.forEach(after => {\n    const afterIndex = plugins.findIndex(plugin => plugin.pluginName === after)\n    if (afterIndex > -1 && afterIndex < pluginIndex) {\n      throw new Error(\n        `React Table: The ${pluginName} plugin hook must be placed before the ${after} plugin hook!`\n      )\n    }\n  })\n}\n\nexport function expandRows(\n  rows,\n  { manualExpandedKey, expanded, expandSubRows = true }\n) {\n  const expandedRows = []\n\n  const handleRow = row => {\n    const key = row.path.join('.')\n\n    row.isExpanded =\n      (row.original && row.original[manualExpandedKey]) ||\n      expanded.includes(key)\n\n    row.canExpand = row.subRows && !!row.subRows.length\n\n    expandedRows.push(row)\n\n    if (expandSubRows && row.subRows && row.subRows.length && row.isExpanded) {\n      row.subRows.forEach(handleRow)\n    }\n  }\n\n  rows.forEach(handleRow)\n\n  return expandedRows\n}\n\n//\n\nfunction makePathArray(obj) {\n  return (\n    flattenDeep(obj)\n      // remove all periods in parts\n      .map(d => String(d).replace('.', '_'))\n      // join parts using period\n      .join('.')\n      // replace brackets with periods\n      .replace(/\\[/g, '.')\n      .replace(/\\]/g, '')\n      // split it back out on periods\n      .split('.')\n  )\n}\n\nfunction flattenDeep(arr, newArr = []) {\n  if (!Array.isArray(arr)) {\n    newArr.push(arr)\n  } else {\n    for (let i = 0; i < arr.length; i += 1) {\n      flattenDeep(arr[i], newArr)\n    }\n  }\n  return newArr\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n//\nimport {\n  applyHooks,\n  applyPropHooks,\n  mergeProps,\n  flexRender,\n  decorateColumnTree,\n  makeHeaderGroups,\n  flattenBy,\n  determineHeaderVisibility,\n} from '../utils'\n\nconst propTypes = {\n  // General\n  data: PropTypes.array.isRequired,\n  columns: PropTypes.arrayOf(PropTypes.object).isRequired,\n  defaultColumn: PropTypes.object,\n  getSubRows: PropTypes.func,\n  getRowID: PropTypes.func,\n  debug: PropTypes.bool,\n}\n\nconst renderErr =\n  'You must specify a valid render component. This could be \"column.Cell\", \"column.Header\", \"column.Filter\", \"column.Aggregated\" or any other custom renderer component.'\n\nexport const defaultState = {}\n\nconst defaultInitialState = {}\nconst defaultColumnInstance = {}\nconst defaultReducer = (old, newState) => newState\nconst defaultGetSubRows = (row, index) => {\n  if (row !== null && row.subRows) {\n    return row.subRows\n  } else {\n    return []\n  }\n}\nconst defaultGetRowID = (row, index) => index\n\nexport const useTable = (props, ...plugins) => {\n  // Validate props\n  PropTypes.checkPropTypes(propTypes, props, 'property', 'useTable')\n\n  // Destructure props\n  let {\n    data,\n    columns: userColumns,\n    initialState = defaultInitialState,\n    state: userState,\n    defaultColumn = defaultColumnInstance,\n    getSubRows = defaultGetSubRows,\n    getRowID = defaultGetRowID,\n    reducer = defaultReducer,\n    debug,\n  } = props\n\n  debug = process.env.NODE_ENV === 'production' ? false : debug\n\n  // But use the users table state if provided\n  let [originalState, originalSetState] = React.useState({\n    ...defaultState,\n    ...initialState,\n  })\n\n  const state = React.useMemo(() => {\n    if (userState) {\n      const newState = {\n        ...originalState,\n      }\n      Object.keys(userState).forEach(key => {\n        newState[key] = userState[key]\n      })\n      return newState\n    }\n    return originalState\n  }, [originalState, userState])\n\n  const setState = React.useCallback(\n    (updater, type) => {\n      return originalSetState(old => {\n        const newState = typeof updater === 'function' ? updater(old) : updater\n        return reducer(old, newState, type)\n      })\n    },\n    [reducer]\n  )\n\n  // The table instance ref\n  let instanceRef = React.useRef({})\n\n  Object.assign(instanceRef.current, {\n    ...props,\n    data, // The raw data\n    state,\n    setState, // The resolved table state\n    plugins, // All resolved plugins\n    hooks: {\n      columnsBeforeHeaderGroups: [],\n      columnsBeforeHeaderGroupsDeps: [],\n      useBeforeDimensions: [],\n      useMain: [],\n      useRows: [],\n      prepareRow: [],\n      getTableProps: [],\n      getTableBodyProps: [],\n      getRowProps: [],\n      getHeaderGroupProps: [],\n      getHeaderProps: [],\n      getCellProps: [],\n    },\n  })\n\n  // Allow plugins to register hooks\n  if (process.env.NODE_ENV === 'development' && debug) console.time('plugins')\n\n  plugins.filter(Boolean).forEach(plugin => {\n    plugin(instanceRef.current.hooks)\n  })\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('plugins')\n\n  // Decorate All the columns\n  let columns = React.useMemo(\n    () => decorateColumnTree(userColumns, defaultColumn),\n    [defaultColumn, userColumns]\n  )\n\n  // Get the flat list of all columns andllow hooks to decorate\n  // those columns (and trigger this memoization via deps)\n  let flatColumns = React.useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('hooks.columnsBeforeHeaderGroups')\n\n    let newColumns = applyHooks(\n      instanceRef.current.hooks.columnsBeforeHeaderGroups,\n      flattenBy(columns, 'columns'),\n      instanceRef.current\n    )\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('hooks.columnsBeforeHeaderGroups')\n    return newColumns\n  }, [\n    columns,\n    debug,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    ...applyHooks(\n      instanceRef.current.hooks.columnsBeforeHeaderGroupsDeps,\n      [],\n      instanceRef.current\n    ),\n  ])\n\n  // Make the headerGroups\n  const headerGroups = React.useMemo(\n    () => makeHeaderGroups(flatColumns, defaultColumn),\n    [defaultColumn, flatColumns]\n  )\n\n  const headers = React.useMemo(() => headerGroups[0].headers, [headerGroups])\n\n  Object.assign(instanceRef.current, {\n    columns,\n    flatColumns,\n    headerGroups,\n    headers,\n  })\n\n  // Access the row model\n  const [rows, flatRows] = React.useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('getAccessedRows')\n\n    let flatRows = []\n\n    // Access the row's data\n    const accessRow = (originalRow, i, depth = 0, parentPath = []) => {\n      // Keep the original reference around\n      const original = originalRow\n\n      const rowID = getRowID(originalRow, i)\n\n      // Make the new path for the row\n      const path = [...parentPath, rowID]\n\n      const row = {\n        original,\n        index: i,\n        path, // used to create a key for each row even if not nested\n        depth,\n        cells: [{}], // This is a dummy cell\n      }\n\n      flatRows.push(row)\n\n      // Process any subRows\n      let subRows = getSubRows(originalRow, i)\n\n      if (subRows) {\n        row.subRows = subRows.map((d, i) => accessRow(d, i, depth + 1, path))\n      }\n\n      // Override common array functions (and the dummy cell's getCellProps function)\n      // to show an error if it is accessed without calling prepareRow\n      const unpreparedAccessWarning = () => {\n        throw new Error(\n          'React-Table: You have not called prepareRow(row) one or more rows you are attempting to render.'\n        )\n      }\n      row.cells.map = unpreparedAccessWarning\n      row.cells.filter = unpreparedAccessWarning\n      row.cells.forEach = unpreparedAccessWarning\n      row.cells[0].getCellProps = unpreparedAccessWarning\n\n      // Create the cells and values\n      row.values = {}\n      flatColumns.forEach(column => {\n        row.values[column.id] = column.accessor\n          ? column.accessor(originalRow, i, { subRows, depth, data })\n          : undefined\n      })\n\n      return row\n    }\n\n    // Use the resolved data\n    const accessedData = data.map((d, i) => accessRow(d, i))\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('getAccessedRows')\n    return [accessedData, flatRows]\n  }, [debug, data, getRowID, getSubRows, flatColumns])\n\n  instanceRef.current.rows = rows\n  instanceRef.current.flatRows = flatRows\n\n  // Determine column visibility\n  determineHeaderVisibility(instanceRef.current)\n\n  // Provide a flat header list for utilities\n  instanceRef.current.flatHeaders = headerGroups.reduce(\n    (all, headerGroup) => [...all, ...headerGroup.headers],\n    []\n  )\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useBeforeDimensions')\n  instanceRef.current = applyHooks(\n    instanceRef.current.hooks.useBeforeDimensions,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useBeforeDimensions')\n\n  calculateDimensions(instanceRef.current)\n\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useMain')\n  instanceRef.current = applyHooks(\n    instanceRef.current.hooks.useMain,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useMain')\n\n  // Each materialized header needs to be assigned a render function and other\n  // prop getter properties here.\n  instanceRef.current.flatHeaders.forEach(column => {\n    // Give columns/headers rendering power\n    column.render = (type, userProps = {}) => {\n      const Comp = typeof type === 'string' ? column[type] : type\n\n      if (typeof Comp === 'undefined') {\n        throw new Error(renderErr)\n      }\n\n      return flexRender(Comp, {\n        ...instanceRef.current,\n        column,\n        ...userProps,\n      })\n    }\n\n    // Give columns/headers a default getHeaderProps\n    column.getHeaderProps = props =>\n      mergeProps(\n        {\n          key: ['header', column.id].join('_'),\n          colSpan: column.totalVisibleHeaderCount,\n        },\n        applyPropHooks(\n          instanceRef.current.hooks.getHeaderProps,\n          column,\n          instanceRef.current\n        ),\n        props\n      )\n  })\n\n  instanceRef.current.headerGroups.forEach((headerGroup, i) => {\n    // Filter out any headers and headerGroups that don't have visible columns\n    headerGroup.headers = headerGroup.headers.filter(header => {\n      const recurse = headers =>\n        headers.filter(header => {\n          if (header.headers) {\n            return recurse(header.headers)\n          }\n          return header.isVisible\n        }).length\n      if (header.headers) {\n        return recurse(header.headers)\n      }\n      return header.isVisible\n    })\n\n    // Give headerGroups getRowProps\n    if (headerGroup.headers.length) {\n      headerGroup.getHeaderGroupProps = (props = {}) =>\n        mergeProps(\n          {\n            key: [`header${i}`].join('_'),\n          },\n          applyPropHooks(\n            instanceRef.current.hooks.getHeaderGroupProps,\n            headerGroup,\n            instanceRef.current\n          ),\n          props\n        )\n\n      return true\n    }\n  })\n\n  // Run the rows (this could be a dangerous hook with a ton of data)\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.time('hooks.useRows')\n  instanceRef.current.rows = applyHooks(\n    instanceRef.current.hooks.useRows,\n    instanceRef.current.rows,\n    instanceRef.current\n  )\n  if (process.env.NODE_ENV === 'development' && debug)\n    console.timeEnd('hooks.useRows')\n\n  // The prepareRow function is absolutely necessary and MUST be called on\n  // any rows the user wishes to be displayed.\n\n  instanceRef.current.prepareRow = React.useCallback(row => {\n    row.getRowProps = props =>\n      mergeProps(\n        { key: ['row', ...row.path].join('_') },\n        applyPropHooks(\n          instanceRef.current.hooks.getRowProps,\n          row,\n          instanceRef.current\n        ),\n        props\n      )\n\n    // Build the visible cells for each row\n    row.cells = instanceRef.current.flatColumns\n      .filter(d => d.isVisible)\n      .map(column => {\n        const cell = {\n          column,\n          row,\n          value: row.values[column.id],\n        }\n\n        // Give each cell a getCellProps base\n        cell.getCellProps = props => {\n          const columnPathStr = [...row.path, column.id].join('_')\n          return mergeProps(\n            {\n              key: ['cell', columnPathStr].join('_'),\n            },\n            applyPropHooks(\n              instanceRef.current.hooks.getCellProps,\n              cell,\n              instanceRef.current\n            ),\n            props\n          )\n        }\n\n        // Give each cell a renderer function (supports multiple renderers)\n        cell.render = (type, userProps = {}) => {\n          const Comp = typeof type === 'string' ? column[type] : type\n\n          if (typeof Comp === 'undefined') {\n            throw new Error(renderErr)\n          }\n\n          return flexRender(Comp, {\n            ...instanceRef.current,\n            column,\n            row,\n            cell,\n            ...userProps,\n          })\n        }\n\n        return cell\n      })\n\n    // need to apply any row specific hooks (useExpanded requires this)\n    applyHooks(instanceRef.current.hooks.prepareRow, row, instanceRef.current)\n  }, [])\n\n  instanceRef.current.getTableProps = userProps =>\n    mergeProps(\n      applyPropHooks(\n        instanceRef.current.hooks.getTableProps,\n        instanceRef.current\n      ),\n      userProps\n    )\n\n  instanceRef.current.getTableBodyProps = userProps =>\n    mergeProps(\n      applyPropHooks(\n        instanceRef.current.hooks.getTableBodyProps,\n        instanceRef.current\n      ),\n      userProps\n    )\n\n  return instanceRef.current\n}\n\nfunction calculateDimensions(instance) {\n  const { headers } = instance\n\n  instance.totalColumnsWidth = calculateHeaderWidths(headers)\n}\n\nfunction calculateHeaderWidths(headers, left = 0) {\n  let sumTotalWidth = 0\n\n  headers.forEach(header => {\n    let { headers: subHeaders } = header\n\n    header.totalLeft = left\n\n    if (subHeaders && subHeaders.length) {\n      header.totalWidth = calculateHeaderWidths(subHeaders, left)\n    } else {\n      header.totalWidth = Math.min(\n        Math.max(header.minWidth, header.width),\n        header.maxWidth\n      )\n    }\n    if (header.isVisible) {\n      left += header.totalWidth\n      sumTotalWidth += header.totalWidth\n    }\n  })\n\n  return sumTotalWidth\n}\n","const actions = {}\nconst types = {}\n\nexport { actions, types }\n\nexport const addActions = (...acts) => {\n  acts.forEach(action => {\n    // Action values are formatted this way to discourage\n    // you (the dev) from interacting with them in any way\n    // other than importing `{ actions } from 'react-table'`\n    // and referencing an action via `actions[actionName]`\n    actions[action] = `React Table Action: ${action}`\n    types[actions[action]] = true\n  })\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport { mergeProps, applyPropHooks, expandRows } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.expanded = []\n\naddActions('toggleExpanded', 'useExpanded')\n\nconst propTypes = {\n  manualExpandedKey: PropTypes.string,\n  paginateExpandedRows: PropTypes.bool,\n}\n\nexport const useExpanded = hooks => {\n  hooks.getExpandedToggleProps = []\n  hooks.useMain.push(useMain)\n}\n\nuseExpanded.pluginName = 'useExpanded'\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useExpanded')\n\n  const {\n    debug,\n    rows,\n    manualExpandedKey = 'expanded',\n    paginateExpandedRows = true,\n    expandSubRows = true,\n    hooks,\n    state: { expanded },\n    setState,\n  } = instance\n\n  const toggleExpandedByPath = (path, set) => {\n    const key = path.join('.')\n\n    return setState(old => {\n      const exists = old.expanded.includes(key)\n      const shouldExist = typeof set !== 'undefined' ? set : !exists\n      let newExpanded = new Set(old.expanded)\n\n      if (!exists && shouldExist) {\n        newExpanded.add(key)\n      } else if (exists && !shouldExist) {\n        newExpanded.delete(key)\n      } else {\n        return old\n      }\n\n      return {\n        ...old,\n        expanded: [...newExpanded.values()],\n      }\n    }, actions.toggleExpanded)\n  }\n\n  hooks.prepareRow.push((row, instance) => {\n    row.toggleExpanded = set => toggleExpandedByPath(row.path, set)\n    const propsFromHooks = applyPropHooks(\n      instance.hooks.getExpandedToggleProps,\n      row,\n      instance\n    )\n    row.getExpandedToggleProps = props => {\n      return mergeProps(\n        {\n          onClick: e => {\n            e.persist()\n            row.toggleExpanded()\n          },\n          style: {\n            cursor: 'pointer',\n          },\n          title: 'Toggle Expanded',\n        },\n        propsFromHooks,\n        props\n      )\n    }\n    return row\n  })\n\n  const expandedRows = useMemo(() => {\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getExpandedRows')\n\n    if (paginateExpandedRows) {\n      return expandRows(rows, { manualExpandedKey, expanded, expandSubRows })\n    }\n\n    return rows\n  }, [\n    debug,\n    paginateExpandedRows,\n    rows,\n    manualExpandedKey,\n    expanded,\n    expandSubRows,\n  ])\n\n  const expandedDepth = findExpandedDepth(expanded)\n\n  return {\n    ...instance,\n    toggleExpandedByPath,\n    expandedDepth,\n    rows: expandedRows,\n  }\n}\n\nfunction findExpandedDepth(expanded) {\n  let maxDepth = 0\n\n  expanded.forEach(key => {\n    const path = key.split('.')\n    maxDepth = Math.max(maxDepth, path.length)\n  })\n\n  return maxDepth\n}","export const text = (rows, id, filterValue) => {\n  rows = rows.filter(row => {\n    const rowValue = row.values[id]\n    return String(rowValue)\n      .toLowerCase()\n      .includes(String(filterValue).toLowerCase())\n  })\n  return rows\n}\n\ntext.autoRemove = val => !val\n\nexport const exactText = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue).toLowerCase() === String(filterValue).toLowerCase()\n      : true\n  })\n}\n\nexactText.autoRemove = val => !val\n\nexport const exactTextCase = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue !== undefined\n      ? String(rowValue) === String(filterValue)\n      : true\n  })\n}\n\nexactTextCase.autoRemove = val => !val\n\nexport const includes = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return filterValue.includes(rowValue)\n  })\n}\n\nincludes.autoRemove = val => !val || !val.length\n\nexport const includesAll = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return (\n      rowValue &&\n      rowValue.length &&\n      filterValue.every(val => rowValue.includes(val))\n    )\n  })\n}\n\nincludesAll.autoRemove = val => !val || !val.length\n\nexport const exact = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue === filterValue\n  })\n}\n\nexact.autoRemove = val => typeof val === 'undefined'\n\nexport const equals = (rows, id, filterValue) => {\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    // eslint-disable-next-line eqeqeq\n    return rowValue == filterValue\n  })\n}\n\nequals.autoRemove = val => val == null\n\nexport const between = (rows, id, filterValue) => {\n  let [min, max] = filterValue || []\n\n  min = typeof min === 'number' ? min : -Infinity\n  max = typeof max === 'number' ? max : Infinity\n\n  if (min > max) {\n    const temp = min\n    min = max\n    max = temp\n  }\n\n  return rows.filter(row => {\n    const rowValue = row.values[id]\n    return rowValue >= min && rowValue <= max\n  })\n}\n\nbetween.autoRemove = val =>\n  !val || (typeof val[0] !== 'number' && typeof val[1] !== 'number')\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { getFirstDefined, isFunction } from '../utils'\nimport * as filterTypes from '../filterTypes'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.filters = {}\n\naddActions('setFilter', 'setAllFilters')\n\nconst propTypes = {\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      disableFilters: PropTypes.bool,\n      Filter: PropTypes.any,\n    })\n  ),\n\n  manualFilters: PropTypes.bool,\n}\n\nexport const useFilters = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseFilters.pluginName = 'useFilters'\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useFilters')\n\n  const {\n    debug,\n    rows,\n    flatRows,\n    flatColumns,\n    filterTypes: userFilterTypes,\n    manualFilters,\n    disableFilters,\n    state: { filters },\n    setState,\n  } = instance\n\n  const preFilteredRows = rows\n  const preFilteredFlatRows = flatRows\n\n  const setFilter = (id, updater) => {\n    const column = flatColumns.find(d => d.id === id)\n\n    if (!column) {\n      throw new Error(`React-Table: Could not find a column with id: ${id}`)\n    }\n\n    const filterMethod = getFilterMethod(\n      column.filter,\n      userFilterTypes || {},\n      filterTypes\n    )\n\n    return setState(old => {\n      const newFilter =\n        typeof updater === 'function' ? updater(old.filters[id]) : updater\n\n      //\n      if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n        const { [id]: remove, ...newFilters } = old.filters\n        return {\n          ...old,\n          filters: newFilters,\n        }\n      }\n\n      return {\n        ...old,\n        filters: {\n          ...old.filters,\n          [id]: newFilter,\n        },\n      }\n    }, actions.setFilter)\n  }\n\n  const setAllFilters = updater => {\n    return setState(old => {\n      const newFilters = typeof updater === 'function' ? updater(old) : updater\n\n      // Filter out undefined values\n      Object.keys(newFilters).forEach(id => {\n        const newFilter = newFilters[id]\n        const column = flatColumns.find(d => d.id === id)\n        const filterMethod = getFilterMethod(\n          column.filter,\n          userFilterTypes || {},\n          filterTypes\n        )\n\n        if (shouldAutoRemove(filterMethod.autoRemove, newFilter)) {\n          delete newFilters[id]\n        }\n      })\n\n      return {\n        ...old,\n        filters: newFilters,\n      }\n    }, actions.setAllFilters)\n  }\n\n  flatColumns.forEach(column => {\n    const { id, accessor, disableFilters: columnDisableFilters } = column\n\n    // Determine if a column is filterable\n    column.canFilter = accessor\n      ? getFirstDefined(\n          columnDisableFilters === true ? false : undefined,\n          disableFilters === true ? false : undefined,\n          true\n        )\n      : false\n\n    // Provide the column a way of updating the filter value\n    column.setFilter = val => setFilter(column.id, val)\n\n    // Provide the current filter value to the column for\n    // convenience\n    column.filterValue = filters[id]\n  })\n\n  // TODO: Create a filter cache for incremental high speed multi-filtering\n  // This gets pretty complicated pretty fast, since you have to maintain a\n  // cache for each row group (top-level rows, and each row's recursive subrows)\n  // This would make multi-filtering a lot faster though. Too far?\n\n  const { filteredRows, filteredFlatRows } = React.useMemo(() => {\n    if (manualFilters || !Object.keys(filters).length) {\n      return {\n        filteredRows: rows,\n        filteredFlatRows: flatRows,\n      }\n    }\n\n    const filteredFlatRows = []\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getFilteredRows')\n\n    // Filters top level and nested rows\n    const filterRows = (rows, depth = 0) => {\n      let filteredRows = rows\n\n      filteredRows = Object.entries(filters).reduce(\n        (filteredSoFar, [columnID, filterValue]) => {\n          // Find the filters column\n          const column = flatColumns.find(d => d.id === columnID)\n\n          if (!column) {\n            return filteredSoFar\n          }\n\n          if (depth === 0) {\n            column.preFilteredRows = filteredSoFar\n          }\n\n          const filterMethod = getFilterMethod(\n            column.filter,\n            userFilterTypes || {},\n            filterTypes\n          )\n\n          if (!filterMethod) {\n            console.warn(\n              `Could not find a valid 'column.filter' for column with the ID: ${column.id}.`\n            )\n            return filteredSoFar\n          }\n\n          // Pass the rows, id, filterValue and column to the filterMethod\n          // to get the filtered rows back\n          column.filteredRows = filterMethod(\n            filteredSoFar,\n            columnID,\n            filterValue,\n            column\n          )\n\n          return column.filteredRows\n        },\n        rows\n      )\n\n      // Apply the filter to any subRows\n      // We technically could do this recursively in the above loop,\n      // but that would severely hinder the API for the user, since they\n      // would be required to do that recursion in some scenarios\n      filteredRows = filteredRows.map(row => {\n        filteredFlatRows.push(row)\n        if (!row.subRows) {\n          return row\n        }\n        return {\n          ...row,\n          subRows:\n            row.subRows && row.subRows.length > 0\n              ? filterRows(row.subRows, depth + 1)\n              : row.subRows,\n        }\n      })\n\n      return filteredRows\n    }\n\n    return {\n      filteredRows: filterRows(rows),\n      filteredFlatRows,\n    }\n  }, [\n    manualFilters,\n    filters,\n    debug,\n    rows,\n    flatRows,\n    flatColumns,\n    userFilterTypes,\n  ])\n\n  React.useMemo(() => {\n    // Now that each filtered column has it's partially filtered rows,\n    // lets assign the final filtered rows to all of the other columns\n    const nonFilteredColumns = flatColumns.filter(\n      column => !Object.keys(filters).includes(column.id)\n    )\n\n    // This essentially enables faceted filter options to be built easily\n    // using every column's preFilteredRows value\n    nonFilteredColumns.forEach(column => {\n      column.preFilteredRows = filteredRows\n      column.filteredRows = filteredRows\n    })\n  }, [filteredRows, filters, flatColumns])\n\n  return {\n    ...instance,\n    setFilter,\n    setAllFilters,\n    preFilteredRows,\n    preFilteredFlatRows,\n    rows: filteredRows,\n    flatRows: filteredFlatRows,\n  }\n}\n\nfunction shouldAutoRemove(autoRemove, value) {\n  return autoRemove ? autoRemove(value) : typeof value === 'undefined'\n}\n\nfunction getFilterMethod(filter, userFilterTypes, filterTypes) {\n  return (\n    isFunction(filter) ||\n    userFilterTypes[filter] ||\n    filterTypes[filter] ||\n    filterTypes.text\n  )\n}\n","export function sum(values, rows) {\n  return values.reduce((sum, next) => sum + next, 0)\n}\n\nexport function average(values, rows) {\n  return Math.round((sum(values, rows) / values.length) * 100) / 100\n}\n\nexport function median(values) {\n  let min = values[0] || ''\n  let max = values[0] || ''\n\n  values.forEach(value => {\n    min = Math.min(min, value)\n    max = Math.max(max, value)\n  })\n\n  return (min + max) / 2\n}\n\nexport function uniqueCount(values) {\n  return new Set(values).size\n}\n\nexport function count(values) {\n  return values.length\n}\n","import { useMemo } from 'react'\nimport PropTypes from 'prop-types'\n\nimport * as aggregations from '../aggregations'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport {\n  mergeProps,\n  applyPropHooks,\n  defaultGroupByFn,\n  getFirstDefined,\n  ensurePluginOrder,\n} from '../utils'\n\ndefaultState.groupBy = []\n\naddActions('toggleGroupBy')\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      aggregate: PropTypes.oneOfType([\n        PropTypes.func,\n        PropTypes.string,\n        PropTypes.arrayOf(\n          PropTypes.oneOfType([PropTypes.func, PropTypes.string])\n        ),\n      ]),\n      disableGrouping: PropTypes.bool,\n      Aggregated: PropTypes.any,\n    })\n  ),\n  groupByFn: PropTypes.func,\n  manualGrouping: PropTypes.bool,\n  disableGrouping: PropTypes.bool,\n  aggregations: PropTypes.object,\n}\n\nexport const useGroupBy = hooks => {\n  hooks.getGroupByToggleProps = []\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups)\n  hooks.columnsBeforeHeaderGroupsDeps.push((deps, instance) => {\n    deps.push(instance.state.groupBy)\n    return deps\n  })\n  hooks.useMain.push(useMain)\n}\n\nuseGroupBy.pluginName = 'useGroupBy'\n\nfunction columnsBeforeHeaderGroups(flatColumns, { state: { groupBy } }) {\n  // Sort grouped columns to the start of the column list\n  // before the headers are built\n\n  const groupByColumns = groupBy.map(g => flatColumns.find(col => col.id === g))\n  const nonGroupByColumns = flatColumns.filter(col => !groupBy.includes(col.id))\n\n  // If a groupByBoundary column is found, place the groupBy's after it\n  const groupByBoundaryColumnIndex =\n    flatColumns.findIndex(column => column.groupByBoundary) + 1\n\n  return [\n    ...nonGroupByColumns.slice(0, groupByBoundaryColumnIndex),\n    ...groupByColumns,\n    ...nonGroupByColumns.slice(groupByBoundaryColumnIndex),\n  ]\n}\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useGroupBy')\n\n  const {\n    debug,\n    rows,\n    flatColumns,\n    flatHeaders,\n    groupByFn = defaultGroupByFn,\n    manualGroupBy,\n    disableGrouping,\n    aggregations: userAggregations = {},\n    hooks,\n    plugins,\n    state: { groupBy },\n    setState,\n  } = instance\n\n  ensurePluginOrder(plugins, [], 'useGroupBy', ['useSortBy', 'useExpanded'])\n\n  flatColumns.forEach(column => {\n    const { id, accessor, disableGrouping: columnDisableGrouping } = column\n    column.isGrouped = groupBy.includes(id)\n    column.groupedIndex = groupBy.indexOf(id)\n\n    column.canGroupBy = accessor\n      ? getFirstDefined(\n          columnDisableGrouping === true ? false : undefined,\n          disableGrouping === true ? false : undefined,\n          true\n        )\n      : false\n\n    if (column.canGroupBy) {\n      column.toggleGroupBy = () => toggleGroupBy(column.id)\n    }\n\n    column.Aggregated = column.Aggregated || column.Cell\n  })\n\n  const toggleGroupBy = (id, toggle) => {\n    return setState(old => {\n      const resolvedToggle =\n        typeof toggle !== 'undefined' ? toggle : !groupBy.includes(id)\n      if (resolvedToggle) {\n        return {\n          ...old,\n          groupBy: [...groupBy, id],\n        }\n      }\n      return {\n        ...old,\n        groupBy: groupBy.filter(d => d !== id),\n      }\n    }, actions.toggleGroupBy)\n  }\n\n  flatHeaders.forEach(\n    // avoid sharing instance in contexts of other functions\n    (instance => header => {\n      const { canGroupBy } = header\n      const groupByTogglePropsFromHooks = applyPropHooks(\n        instance.hooks.getGroupByToggleProps,\n        header,\n        instance\n      )\n      header.getGroupByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canGroupBy\n              ? e => {\n                  e.persist()\n                  header.toggleGroupBy()\n                }\n              : undefined,\n            style: {\n              cursor: canGroupBy ? 'pointer' : undefined,\n            },\n            title: 'Toggle GroupBy',\n          },\n          groupByTogglePropsFromHooks,\n          props\n        )\n      }\n    })(instance)\n  )\n\n  hooks.prepareRow.push(row => {\n    row.cells.forEach(cell => {\n      // Grouped cells are in the groupBy and the pivot cell for the row\n      cell.isGrouped = cell.column.isGrouped && cell.column.id === row.groupByID\n      // Repeated cells are any columns in the groupBy that are not grouped\n      cell.isRepeatedValue = !cell.isGrouped && cell.column.isGrouped\n      // Aggregated cells are not grouped, not repeated, but still have subRows\n      cell.isAggregated =\n        !cell.isGrouped && !cell.isRepeatedValue && row.canExpand\n    })\n    return row\n  })\n\n  const groupedRows = useMemo(() => {\n    if (manualGroupBy || !groupBy.length) {\n      return rows\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.info('getGroupedRows')\n    // Find the columns that can or are aggregating\n\n    // Uses each column to aggregate rows into a single value\n    const aggregateRowsToValues = (rows, isSourceRows) => {\n      const values = {}\n\n      flatColumns.forEach(column => {\n        // Don't aggregate columns that are in the groupBy\n        if (groupBy.includes(column.id)) {\n          values[column.id] = rows[0] ? rows[0].values[column.id] : null\n          return\n        }\n\n        const columnValues = rows.map(d => d.values[column.id])\n\n        let aggregator = column.aggregate\n\n        if (Array.isArray(aggregator)) {\n          if (aggregator.length !== 2) {\n            console.info({ column })\n            throw new Error(\n              `React Table: Complex aggregators must have 2 values, eg. aggregate: ['sum', 'count']. More info above...`\n            )\n          }\n          if (isSourceRows) {\n            aggregator = aggregator[1]\n          } else {\n            aggregator = aggregator[0]\n          }\n        }\n\n        let aggregateFn =\n          typeof aggregator === 'function'\n            ? aggregator\n            : userAggregations[aggregator] || aggregations[aggregator]\n\n        if (aggregateFn) {\n          values[column.id] = aggregateFn(columnValues, rows)\n        } else if (aggregator) {\n          console.info({ column })\n          throw new Error(\n            `React Table: Invalid aggregate option for column listed above`\n          )\n        } else {\n          values[column.id] = null\n        }\n      })\n      return values\n    }\n\n    // Recursively group the data\n    const groupRecursively = (rows, depth = 0, parentPath = []) => {\n      // This is the last level, just return the rows\n      if (depth >= groupBy.length) {\n        return rows\n      }\n\n      const columnID = groupBy[depth]\n\n      // Group the rows together for this level\n      let groupedRows = groupByFn(rows, columnID)\n\n      // Recurse to sub rows before aggregation\n      groupedRows = Object.entries(groupedRows).map(\n        ([groupByVal, subRows], index) => {\n          const path = [...parentPath, `${columnID}:${groupByVal}`]\n\n          subRows = groupRecursively(subRows, depth + 1, path)\n\n          const values = aggregateRowsToValues(\n            subRows,\n            depth + 1 >= groupBy.length\n          )\n\n          const row = {\n            isAggregated: true,\n            groupByID: columnID,\n            groupByVal,\n            values,\n            subRows,\n            depth,\n            index,\n            path,\n          }\n\n          return row\n        }\n      )\n\n      return groupedRows\n    }\n\n    // Assign the new data\n    return groupRecursively(rows)\n  }, [\n    manualGroupBy,\n    groupBy,\n    debug,\n    rows,\n    flatColumns,\n    userAggregations,\n    groupByFn,\n  ])\n\n  return {\n    ...instance,\n    toggleGroupBy,\n    rows: groupedRows,\n    preGroupedRows: rows,\n  }\n}\n","const reSplitAlphaNumeric = /([0-9]+)/gm\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nexport const alphanumeric = (rowA, rowB, columnID) => {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n  // Force to strings (or \"\" for unsupported types)\n  a = toString(a)\n  b = toString(b)\n\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  a = a.split(reSplitAlphaNumeric).filter(Boolean)\n  b = b.split(reSplitAlphaNumeric).filter(Boolean)\n\n  // While\n  while (a.length && b.length) {\n    let aa = a.shift()\n    let bb = b.shift()\n\n    const an = parseInt(aa, 10)\n    const bn = parseInt(bb, 10)\n\n    const combo = [an, bn].sort()\n\n    // Both are string\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1\n      }\n      if (bb > aa) {\n        return -1\n      }\n      continue\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1\n    }\n    if (bn > an) {\n      return -1\n    }\n  }\n\n  return a.length - b.length\n}\n\nexport function datetime(rowA, rowB, columnID) {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n\n  a = a.getTime()\n  b = b.getTime()\n\n  return compareBasic(a, b)\n}\n\nexport function basic(rowA, rowB, columnID) {\n  let a = getRowValueByColumnID(rowA, columnID)\n  let b = getRowValueByColumnID(rowB, columnID)\n\n  return compareBasic(a, b)\n}\n\n// Utils\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1\n}\n\nfunction getRowValueByColumnID(row, columnID) {\n  return row.values[columnID]\n}\n\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return ''\n    }\n    return String(a)\n  }\n  if (typeof a === 'string') {\n    return a\n  }\n  return ''\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { ensurePluginOrder, defaultColumn } from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport * as sortTypes from '../sortTypes'\nimport {\n  mergeProps,\n  applyPropHooks,\n  getFirstDefined,\n  defaultOrderByFn,\n  isFunction,\n} from '../utils'\n\ndefaultState.sortBy = []\ndefaultColumn.sortType = 'alphanumeric'\ndefaultColumn.sortDescFirst = false\n\naddActions('sortByChange')\n\nconst propTypes = {\n  // General\n  columns: PropTypes.arrayOf(\n    PropTypes.shape({\n      sortType: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n      sortDescFirst: PropTypes.bool,\n      disableSorting: PropTypes.bool,\n    })\n  ),\n  orderByFn: PropTypes.func,\n  sortTypes: PropTypes.object,\n  manualSorting: PropTypes.bool,\n  disableSorting: PropTypes.bool,\n  disableMultiSort: PropTypes.bool,\n  isMultiSortEvent: PropTypes.func,\n  maxMultiSortColCount: PropTypes.number,\n  disableSortRemove: PropTypes.bool,\n  disableMultiRemove: PropTypes.bool,\n}\n\nexport const useSortBy = hooks => {\n  hooks.useMain.push(useMain)\n  // Add custom hooks\n  hooks.getSortByToggleProps = []\n}\n\nuseSortBy.pluginName = 'useSortBy'\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useSortBy')\n\n  const {\n    debug,\n    rows,\n    flatColumns,\n    orderByFn = defaultOrderByFn,\n    sortTypes: userSortTypes,\n    manualSorting,\n    disableSorting,\n    disableSortRemove,\n    disableMultiRemove,\n    disableMultiSort,\n    isMultiSortEvent = e => e.shiftKey,\n    maxMultiSortColCount = Number.MAX_SAFE_INTEGER,\n    flatHeaders,\n    state: { sortBy },\n    setState,\n    plugins,\n  } = instance\n\n  ensurePluginOrder(plugins, ['useFilters'], 'useSortBy', [])\n\n  // Updates sorting based on a columnID, desc flag and multi flag\n  const toggleSortBy = (columnID, desc, multi) => {\n    return setState(old => {\n      const { sortBy } = old\n\n      // Find the column for this columnID\n      const column = flatColumns.find(d => d.id === columnID)\n      const { sortDescFirst } = column\n\n      // Find any existing sortBy for this column\n      const existingSortBy = sortBy.find(d => d.id === columnID)\n      const existingIndex = sortBy.findIndex(d => d.id === columnID)\n      const hasDescDefined = typeof desc !== 'undefined' && desc !== null\n\n      let newSortBy = []\n\n      // What should we do with this sort action?\n      let action\n\n      if (!disableMultiSort && multi) {\n        if (existingSortBy) {\n          action = 'toggle'\n        } else {\n          action = 'add'\n        }\n      } else {\n        // Normal mode\n        if (existingIndex !== sortBy.length - 1) {\n          action = 'replace'\n        } else if (existingSortBy) {\n          action = 'toggle'\n        } else {\n          action = 'replace'\n        }\n      }\n\n      // Handle toggle states that will remove the sortBy\n      if (\n        action === 'toggle' && // Must be toggling\n        !disableSortRemove && // If disableSortRemove, disable in general\n        !hasDescDefined && // Must not be setting desc\n        (multi ? !disableMultiRemove : true) && // If multi, don't allow if disableMultiRemove\n        ((existingSortBy && // Finally, detect if it should indeed be removed\n          (existingSortBy.desc && !sortDescFirst)) ||\n          (!existingSortBy.desc && sortDescFirst))\n      ) {\n        action = 'remove'\n      }\n\n      if (action === 'replace') {\n        newSortBy = [\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : sortDescFirst,\n          },\n        ]\n      } else if (action === 'add') {\n        newSortBy = [\n          ...sortBy,\n          {\n            id: columnID,\n            desc: hasDescDefined ? desc : sortDescFirst,\n          },\n        ]\n        // Take latest n columns\n        newSortBy.splice(0, newSortBy.length - maxMultiSortColCount)\n      } else if (action === 'toggle') {\n        // This flips (or sets) the\n        newSortBy = sortBy.map(d => {\n          if (d.id === columnID) {\n            return {\n              ...d,\n              desc: hasDescDefined ? desc : !existingSortBy.desc,\n            }\n          }\n          return d\n        })\n      } else if (action === 'remove') {\n        newSortBy = sortBy.filter(d => d.id !== columnID)\n      }\n\n      return {\n        ...old,\n        sortBy: newSortBy,\n      }\n    }, actions.sortByChange)\n  }\n\n  // Add the getSortByToggleProps method to columns and headers\n  flatHeaders.forEach(\n    // avoid sharing instance in contexts of other functions\n    (instance => column => {\n      const { accessor, disableSorting: columnDisableSorting, id } = column\n\n      const canSort = accessor\n        ? getFirstDefined(\n            columnDisableSorting === true ? false : undefined,\n            disableSorting === true ? false : undefined,\n            true\n          )\n        : false\n\n      column.canSort = canSort\n\n      if (column.canSort) {\n        column.toggleSortBy = (desc, multi) =>\n          toggleSortBy(column.id, desc, multi)\n\n        column.clearSorting = () => {\n          return setState(old => {\n            const { sortBy } = old\n            const newSortBy = sortBy.filter(d => d.id !== column.id)\n            return {\n              ...old,\n              sortBy: newSortBy,\n            }\n          }, actions.sortByChange)\n        }\n      }\n\n      const sortByTogglePropsFromHooks = applyPropHooks(\n        instance.hooks.getSortByToggleProps,\n        column,\n        instance\n      )\n      column.getSortByToggleProps = props => {\n        return mergeProps(\n          {\n            onClick: canSort\n              ? e => {\n                  e.persist()\n                  column.toggleSortBy(\n                    undefined,\n                    !disableMultiSort && isMultiSortEvent(e)\n                  )\n                }\n              : undefined,\n            style: {\n              cursor: canSort ? 'pointer' : undefined,\n            },\n            title: 'Toggle SortBy',\n          },\n          sortByTogglePropsFromHooks,\n          props\n        )\n      }\n\n      const columnSort = sortBy.find(d => d.id === id)\n      column.isSorted = !!columnSort\n      column.sortedIndex = sortBy.findIndex(d => d.id === id)\n      column.isSortedDesc = column.isSorted ? columnSort.desc : undefined\n    })(instance)\n  )\n\n  const sortedRows = React.useMemo(() => {\n    if (manualSorting || !sortBy.length) {\n      return rows\n    }\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.time('getSortedRows')\n\n    // Filter out sortBys that correspond to non existing columns\n    const availableSortBy = sortBy.filter(sort =>\n      flatColumns.find(col => col.id === sort.id)\n    )\n\n    const sortData = rows => {\n      // Use the orderByFn to compose multiple sortBy's together.\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = orderByFn(\n        rows,\n        availableSortBy.map(sort => {\n          // Support custom sorting methods for each column\n          const column = flatColumns.find(d => d.id === sort.id)\n\n          if (!column) {\n            throw new Error(\n              `React-Table: Could not find a column with id: ${sort.id} while sorting`\n            )\n          }\n\n          const { sortType } = column\n\n          // Look up sortBy functions in this order:\n          // column function\n          // column string lookup on user sortType\n          // column string lookup on built-in sortType\n          // default function\n          // default string lookup on user sortType\n          // default string lookup on built-in sortType\n          const sortMethod =\n            isFunction(sortType) ||\n            (userSortTypes || {})[sortType] ||\n            sortTypes[sortType]\n\n          if (!sortMethod) {\n            throw new Error(\n              `React-Table: Could not find a valid sortType of '${sortType}' for column '${sort.id}'.`\n            )\n          }\n\n          // Return the correct sortFn.\n          // This function should always return in ascending order\n          return (a, b) => sortMethod(a, b, sort.id)\n        }),\n        // Map the directions\n        availableSortBy.map(sort => {\n          // Detect and use the sortInverted option\n          const column = flatColumns.find(d => d.id === sort.id)\n\n          if (column && column.sortInverted) {\n            return sort.desc\n          }\n\n          return !sort.desc\n        })\n      )\n\n      // If there are sub-rows, sort them\n      sortedData.forEach(row => {\n        if (!row.subRows || row.subRows.length <= 1) {\n          return\n        }\n        row.subRows = sortData(row.subRows)\n      })\n\n      return sortedData\n    }\n\n    if (process.env.NODE_ENV === 'development' && debug)\n      console.timeEnd('getSortedRows')\n\n    return sortData(rows)\n  }, [\n    manualSorting,\n    sortBy,\n    debug,\n    rows,\n    flatColumns,\n    orderByFn,\n    userSortTypes,\n  ])\n\n  return {\n    ...instance,\n    toggleSortBy,\n    rows: sortedRows,\n    preSortedRows: rows,\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\n//\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\nimport { ensurePluginOrder, safeUseLayoutEffect, expandRows } from '../utils'\n\ndefaultState.pageSize = 10\ndefaultState.pageIndex = 0\n\naddActions('pageChange', 'pageSizeChange')\n\nconst propTypes = {\n  // General\n  manualPagination: PropTypes.bool,\n  paginateExpandedRows: PropTypes.bool,\n}\n\nexport const usePagination = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nusePagination.pluginName = 'usePagination'\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'usePagination')\n\n  const {\n    data,\n    rows,\n    manualPagination,\n    disablePageResetOnDataChange,\n    manualExpandedKey = 'expanded',\n    debug,\n    plugins,\n    pageCount: userPageCount,\n    paginateExpandedRows = true,\n    expandSubRows = true,\n    state: { pageSize, pageIndex, filters, groupBy, sortBy, expanded },\n    setState,\n  } = instance\n\n  ensurePluginOrder(\n    plugins,\n    ['useFilters', 'useGroupBy', 'useSortBy', 'useExpanded'],\n    'usePagination',\n    []\n  )\n\n  const rowDep = manualPagination ? null : data\n\n  const isPageIndexMountedRef = React.useRef()\n\n  // Bypass any effects from firing when this changes\n  const disablePageResetOnDataChangeRef = React.useRef()\n  disablePageResetOnDataChangeRef.current = disablePageResetOnDataChange\n\n  safeUseLayoutEffect(() => {\n    if (\n      isPageIndexMountedRef.current &&\n      !disablePageResetOnDataChangeRef.current\n    ) {\n      setState(\n        old => ({\n          ...old,\n          pageIndex: 0,\n        }),\n        actions.pageChange\n      )\n    }\n    isPageIndexMountedRef.current = true\n  }, [setState, rowDep, filters, groupBy, sortBy])\n\n  const pageCount = manualPagination\n    ? userPageCount\n    : Math.ceil(rows.length / pageSize)\n\n  const pageOptions = React.useMemo(\n    () => (pageCount > 0 ? [...new Array(pageCount)].map((d, i) => i) : []),\n    [pageCount]\n  )\n\n  const page = React.useMemo(() => {\n    let page\n\n    if (manualPagination) {\n      page = rows\n    } else {\n      if (process.env.NODE_ENV === 'development' && debug)\n        console.info('getPage')\n\n      const pageStart = pageSize * pageIndex\n      const pageEnd = pageStart + pageSize\n\n      page = rows.slice(pageStart, pageEnd)\n    }\n\n    if (paginateExpandedRows) {\n      return page\n    }\n\n    return expandRows(page, { manualExpandedKey, expanded, expandSubRows })\n  }, [\n    debug,\n    expandSubRows,\n    expanded,\n    manualExpandedKey,\n    manualPagination,\n    pageIndex,\n    pageSize,\n    paginateExpandedRows,\n    rows,\n  ])\n\n  const canPreviousPage = pageIndex > 0\n  const canNextPage = pageCount === -1 || pageIndex < pageCount - 1\n\n  const gotoPage = React.useCallback(\n    updater => {\n      if (process.env.NODE_ENV === 'development' && debug)\n        console.info('gotoPage')\n      return setState(old => {\n        const newPageIndex =\n          typeof updater === 'function' ? updater(old.pageIndex) : updater\n\n        if (newPageIndex < 0 || newPageIndex > pageCount - 1) {\n          return old\n        }\n        return {\n          ...old,\n          pageIndex: newPageIndex,\n        }\n      }, actions.pageChange)\n    },\n    [debug, pageCount, setState]\n  )\n\n  const previousPage = React.useCallback(() => {\n    return gotoPage(old => old - 1)\n  }, [gotoPage])\n\n  const nextPage = React.useCallback(() => {\n    return gotoPage(old => old + 1)\n  }, [gotoPage])\n\n  const setPageSize = React.useCallback(\n    pageSize => {\n      setState(old => {\n        const topRowIndex = old.pageSize * old.pageIndex\n        const pageIndex = Math.floor(topRowIndex / pageSize)\n        return {\n          ...old,\n          pageIndex,\n          pageSize,\n        }\n      }, actions.pageSizeChange)\n    },\n    [setState]\n  )\n\n  return {\n    ...instance,\n    pageOptions,\n    pageCount,\n    page,\n    canPreviousPage,\n    canNextPage,\n    gotoPage,\n    previousPage,\n    nextPage,\n    setPageSize,\n    pageIndex,\n    pageSize,\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport {\n  mergeProps,\n  applyPropHooks,\n  ensurePluginOrder,\n  safeUseLayoutEffect,\n} from '../utils'\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.selectedRowPaths = []\n\naddActions('toggleRowSelected', 'toggleRowSelectedAll')\n\nconst propTypes = {\n  manualRowSelectedKey: PropTypes.string,\n}\n\nexport const useRowSelect = hooks => {\n  hooks.getToggleRowSelectedProps = []\n  hooks.getToggleAllRowsSelectedProps = []\n  hooks.useRows.push(useRows)\n  hooks.useMain.push(useMain)\n}\n\nuseRowSelect.pluginName = 'useRowSelect'\n\nfunction useRows(rows, instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useRowSelect')\n\n  const {\n    state: { selectedRowPaths },\n  } = instance\n\n  instance.selectedFlatRows = React.useMemo(() => {\n    const selectedFlatRows = []\n    rows.forEach(row => {\n      if (row.isAggregated) {\n        const subRowPaths = row.subRows.map(row => row.path)\n        row.isSelected = subRowPaths.every(path =>\n          selectedRowPaths.includes(path.join('.'))\n        )\n      } else {\n        row.isSelected = selectedRowPaths.includes(row.path.join('.'))\n      }\n      if (row.isSelected) {\n        selectedFlatRows.push(row)\n      }\n    })\n\n    return selectedFlatRows\n  }, [rows, selectedRowPaths])\n\n  return rows\n}\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useRowSelect')\n\n  const {\n    hooks,\n    manualRowSelectedKey = 'isSelected',\n    disableSelectedRowsResetOnDataChange,\n    plugins,\n    flatRows,\n    data,\n    state: { selectedRowPaths },\n    setState,\n  } = instance\n\n  ensurePluginOrder(\n    plugins,\n    ['useFilters', 'useGroupBy', 'useSortBy'],\n    'useRowSelect',\n    []\n  )\n\n  const flatRowPaths = flatRows.map(d => d.path.join('.'))\n\n  let isAllRowsSelected = !!flatRowPaths.length && !!selectedRowPaths.length\n\n  if (isAllRowsSelected) {\n    if (flatRowPaths.some(d => !selectedRowPaths.includes(d))) {\n      isAllRowsSelected = false\n    }\n  }\n\n  const isRowSelectedMountedRef = React.useRef()\n\n  // Bypass any effects from firing when this changes\n  const disableSelectedRowsResetOnDataChangeRef = React.useRef()\n  disableSelectedRowsResetOnDataChangeRef.current = disableSelectedRowsResetOnDataChange\n\n  safeUseLayoutEffect(() => {\n    if (\n      isRowSelectedMountedRef.current &&\n      !disableSelectedRowsResetOnDataChangeRef.current\n    ) {\n      setState(\n        old => ({\n          ...old,\n          selectedRowPaths: [],\n        }),\n        actions.pageChange\n      )\n    }\n    isRowSelectedMountedRef.current = true\n  }, [setState, data])\n\n  const toggleRowSelectedAll = set => {\n    setState(old => {\n      const selectAll = typeof set !== 'undefined' ? set : !isAllRowsSelected\n      return {\n        ...old,\n        selectedRowPaths: selectAll ? flatRowPaths : [],\n      }\n    }, actions.toggleRowSelectedAll)\n  }\n\n  const updateParentRow = (selectedRowPaths, path) => {\n    const parentPath = path.slice(0, path.length - 1)\n    const parentKey = parentPath.join('.')\n    const selected =\n      flatRowPaths.filter(rowPath => {\n        const path = rowPath\n        return (\n          path !== parentKey &&\n          path.startsWith(parentKey) &&\n          !selectedRowPaths.has(path)\n        )\n      }).length === 0\n    if (selected) {\n      selectedRowPaths.add(parentKey)\n    } else {\n      selectedRowPaths.delete(parentKey)\n    }\n    if (parentPath.length > 1) updateParentRow(selectedRowPaths, parentPath)\n  }\n\n  const toggleRowSelected = (path, set) => {\n    const key = path.join('.')\n    const childRowPrefixKey = [key, '.'].join('')\n\n    return setState(old => {\n      // Join the paths of deep rows\n      // to make a key, then manage all of the keys\n      // in a flat object\n      const exists = old.selectedRowPaths.includes(key)\n      const shouldExist = typeof set !== 'undefined' ? set : !exists\n      let newSelectedRows = new Set(old.selectedRowPaths)\n\n      if (!exists && shouldExist) {\n        flatRowPaths.forEach(rowPath => {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.add(rowPath)\n          }\n        })\n      } else if (exists && !shouldExist) {\n        flatRowPaths.forEach(rowPath => {\n          if (rowPath === key || rowPath.startsWith(childRowPrefixKey)) {\n            newSelectedRows.delete(rowPath)\n          }\n        })\n      } else {\n        return old\n      }\n\n      // If the row is a subRow update\n      // its parent row to reflect changes\n      if (path.length > 1) updateParentRow(newSelectedRows, path)\n\n      return {\n        ...old,\n        selectedRowPaths: [...newSelectedRows.values()],\n      }\n    }, actions.toggleRowSelected)\n  }\n\n  const toggleAllRowsSelectedPropsFromHooks = applyPropHooks(\n    instance.hooks.getToggleAllRowsSelectedProps,\n    instance\n  )\n  const getToggleAllRowsSelectedProps = props => {\n    return mergeProps(\n      {\n        onChange: e => {\n          toggleRowSelectedAll(e.target.checked)\n        },\n        style: {\n          cursor: 'pointer',\n        },\n        checked: isAllRowsSelected,\n        title: 'Toggle All Rows Selected',\n      },\n      toggleAllRowsSelectedPropsFromHooks,\n      props\n    )\n  }\n\n  hooks.prepareRow.push((row, instance) => {\n    const toggleRowSelectedPropsFromHooks = applyPropHooks(\n      instance.hooks.getToggleRowSelectedProps,\n      row,\n      instance\n    )\n    // Aggregate rows have entirely different select logic\n    if (row.isAggregated) {\n      const subRowPaths = row.subRows.map(row => row.path)\n      row.toggleRowSelected = set => {\n        set = typeof set !== 'undefined' ? set : !row.isSelected\n        subRowPaths.forEach(path => {\n          toggleRowSelected(path, set)\n        })\n      }\n      row.getToggleRowSelectedProps = props => {\n        let checked = false\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true\n        } else {\n          checked = row.isSelected\n        }\n\n        return mergeProps(\n          {\n            onChange: e => {\n              row.toggleRowSelected(e.target.checked)\n            },\n            style: {\n              cursor: 'pointer',\n            },\n            checked,\n            title: 'Toggle Row Selected',\n          },\n          toggleRowSelectedPropsFromHooks,\n          props\n        )\n      }\n    } else {\n      row.toggleRowSelected = set => toggleRowSelected(row.path, set)\n      row.getToggleRowSelectedProps = props => {\n        let checked = false\n\n        if (row.original && row.original[manualRowSelectedKey]) {\n          checked = true\n        } else {\n          checked = row.isSelected\n        }\n\n        return mergeProps(\n          {\n            onChange: e => {\n              row.toggleRowSelected(e.target.checked)\n            },\n            style: {\n              cursor: 'pointer',\n            },\n            checked,\n            title: 'Toggle Row Selected',\n          },\n          toggleRowSelectedPropsFromHooks,\n          props\n        )\n      }\n    }\n\n    return row\n  })\n\n  return {\n    ...instance,\n    toggleRowSelected,\n    toggleRowSelectedAll,\n    getToggleAllRowsSelectedProps,\n    isAllRowsSelected,\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.rowState = {}\n\naddActions('setRowState', 'setCellState')\n\nconst propTypes = {\n  initialRowStateAccessor: PropTypes.func,\n}\n\nexport const useRowState = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseRowState.pluginName = 'useRowState'\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useRowState')\n\n  const {\n    hooks,\n    rows,\n    initialRowStateAccessor,\n    state: { rowState },\n    setState,\n  } = instance\n\n  const setRowState = React.useCallback(\n    (path, updater, action = actions.setRowState) => {\n      const pathKey = path.join('.')\n      return setState(old => {\n        return {\n          ...old,\n          rowState: {\n            ...old.rowState,\n            [pathKey]:\n              typeof updater === 'function'\n                ? updater(old.rowState[pathKey])\n                : updater,\n          },\n        }\n      }, action)\n    },\n    [setState]\n  )\n\n  const setCellState = React.useCallback(\n    (rowPath, columnID, updater) => {\n      return setRowState(\n        rowPath,\n        old => {\n          return {\n            ...old,\n            cellState: {\n              ...old.cellState,\n              [columnID]:\n                typeof updater === 'function'\n                  ? updater(old.cellState[columnID])\n                  : updater,\n            },\n          }\n        },\n        actions.setCellState\n      )\n    },\n    [setRowState]\n  )\n\n  const rowsMountedRef = React.useRef()\n\n  // When data changes, reset row and cell state\n  React.useEffect(() => {\n    if (rowsMountedRef.current) {\n      setState(old => {\n        return {\n          ...old,\n          rowState: {},\n        }\n      }, actions.setRowState)\n    }\n\n    rowsMountedRef.current = true\n  }, [rows, setState])\n\n  hooks.prepareRow.push(row => {\n    const pathKey = row.path.join('.')\n\n    if (row.original) {\n      row.state =\n        (typeof rowState[pathKey] !== 'undefined'\n          ? rowState[pathKey]\n          : initialRowStateAccessor && initialRowStateAccessor(row)) || {}\n\n      row.setState = updater => {\n        return setRowState(row.path, updater)\n      }\n\n      row.cells.forEach(cell => {\n        cell.state = row.state.cellState || {}\n\n        cell.setState = updater => {\n          return setCellState(row.path, cell.column.id, updater)\n        }\n      })\n    }\n\n    return row\n  })\n\n  return {\n    ...instance,\n    setRowState,\n    setCellState,\n  }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { addActions, actions } from '../actions'\nimport { defaultState } from '../hooks/useTable'\n\ndefaultState.columnOrder = []\n\naddActions('setColumnOrder')\n\nconst propTypes = {\n  initialRowStateAccessor: PropTypes.func,\n}\n\nexport const useColumnOrder = hooks => {\n  hooks.columnsBeforeHeaderGroupsDeps.push((deps, instance) => {\n    return [...deps, instance.state.columnOrder]\n  })\n  hooks.columnsBeforeHeaderGroups.push(columnsBeforeHeaderGroups)\n  hooks.useMain.push(useMain)\n}\n\nuseColumnOrder.pluginName = 'useColumnOrder'\n\nfunction columnsBeforeHeaderGroups(columns, instance) {\n  const {\n    state: { columnOrder },\n  } = instance\n\n  // If there is no order, return the normal columns\n  if (!columnOrder || !columnOrder.length) {\n    return columns\n  }\n\n  const columnOrderCopy = [...columnOrder]\n\n  // If there is an order, make a copy of the columns\n  const columnsCopy = [...columns]\n\n  // And make a new ordered array of the columns\n  const columnsInOrder = []\n\n  // Loop over the columns and place them in order into the new array\n  while (columnsCopy.length && columnOrderCopy.length) {\n    const targetColumnID = columnOrderCopy.shift()\n    const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnID)\n    if (foundIndex > -1) {\n      columnsInOrder.push(columnsCopy.splice(foundIndex, 1)[0])\n    }\n  }\n\n  // If there are any columns left, add them to the end\n  return [...columnsInOrder, ...columnsCopy]\n}\n\nfunction useMain(instance) {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useColumnOrder')\n\n  const { setState } = instance\n\n  const setColumnOrder = React.useCallback(\n    updater => {\n      return setState(old => {\n        return {\n          ...old,\n          columnOrder:\n            typeof updater === 'function' ? updater(old.columnOrder) : updater,\n        }\n      }, actions.setColumnOrder)\n    },\n    [setState]\n  )\n\n  return {\n    ...instance,\n    setColumnOrder,\n  }\n}\n","import PropTypes from 'prop-types'\n\n//\n\nimport { defaultState } from '../hooks/useTable'\nimport { defaultColumn, getFirstDefined } from '../utils'\nimport { mergeProps, applyPropHooks } from '../utils'\n\ndefaultState.columnResizing = {\n  columnWidths: {},\n}\n\ndefaultColumn.canResize = true\n\nconst propTypes = {}\n\nexport const useResizeColumns = hooks => {\n  hooks.getResizerProps = []\n  hooks.useBeforeDimensions.push(useBeforeDimensions)\n}\n\nuseResizeColumns.pluginName = 'useResizeColumns'\n\nconst useBeforeDimensions = instance => {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useResizeColumns')\n\n  const {\n    flatHeaders,\n    disableResizing,\n    hooks: { getHeaderProps },\n    state: { columnResizing },\n    setState,\n  } = instance\n\n  getHeaderProps.push(() => {\n    return {\n      style: {\n        position: 'relative',\n      },\n    }\n  })\n\n  const onMouseDown = (e, header) => {\n    const headersToResize = getLeafHeaders(header)\n    const startWidths = headersToResize.map(header => header.totalWidth)\n    const startX = e.clientX\n\n    const onMouseMove = e => {\n      const currentX = e.clientX\n      const deltaX = currentX - startX\n\n      const percentageDeltaX = deltaX / headersToResize.length\n\n      const newColumnWidths = {}\n      headersToResize.forEach((header, index) => {\n        newColumnWidths[header.id] = Math.max(\n          startWidths[index] + percentageDeltaX,\n          0\n        )\n      })\n\n      setState(old => ({\n        ...old,\n        columnResizing: {\n          ...old.columnResizing,\n          columnWidths: {\n            ...old.columnResizing.columnWidths,\n            ...newColumnWidths,\n          },\n        },\n      }))\n    }\n\n    const onMouseUp = e => {\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n\n      setState(old => ({\n        ...old,\n        columnResizing: {\n          ...old.columnResizing,\n          startX: null,\n          isResizingColumn: null,\n        },\n      }))\n    }\n\n    document.addEventListener('mousemove', onMouseMove)\n    document.addEventListener('mouseup', onMouseUp)\n\n    setState(old => ({\n      ...old,\n      columnResizing: {\n        ...old.columnResizing,\n        startX,\n        isResizingColumn: header.id,\n      },\n    }))\n  }\n\n  flatHeaders.forEach(\n    (instance => header => {\n      const canResize = getFirstDefined(\n        header.disableResizing === true ? false : undefined,\n        disableResizing === true ? false : undefined,\n        true\n      )\n\n      header.canResize = canResize\n      header.width = columnResizing.columnWidths[header.id] || header.width\n      header.isResizing = columnResizing.isResizingColumn === header.id\n\n      if (canResize) {\n        const resizerPropsFromHooks = applyPropHooks(\n          instance.hooks.getResizerProps,\n          header,\n          instance\n        )\n        header.getResizerProps = userProps => {\n          return mergeProps(\n            {\n              onMouseDown: e => e.persist() || onMouseDown(e, header),\n              style: {\n                cursor: 'ew-resize',\n              },\n              draggable: false,\n            },\n            resizerPropsFromHooks,\n            userProps\n          )\n        }\n      }\n    })(instance)\n  )\n\n  return instance\n}\n\nfunction getLeafHeaders(header) {\n  const leafHeaders = []\n  const recurseHeader = header => {\n    if (header.columns && header.columns.length) {\n      header.columns.map(recurseHeader)\n    }\n    leafHeaders.push(header)\n  }\n  recurseHeader(header)\n  return leafHeaders\n}\n","import PropTypes from 'prop-types'\n\nconst propTypes = {}\n\nexport const useAbsoluteLayout = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseAbsoluteLayout.pluginName = 'useAbsoluteLayout'\n\nconst useMain = instance => {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useAbsoluteLayout')\n\n  const {\n    totalColumnsWidth,\n    hooks: {\n      getRowProps,\n      getTableBodyProps,\n      getHeaderGroupProps,\n      getHeaderProps,\n      getCellProps,\n    },\n  } = instance\n\n  const rowStyles = {\n    style: {\n      position: 'relative',\n      width: `${totalColumnsWidth}px`,\n    },\n  }\n\n  getTableBodyProps.push(() => rowStyles)\n  getRowProps.push(() => rowStyles)\n  getHeaderGroupProps.push(() => rowStyles)\n\n  // Calculating column/cells widths\n  const cellStyles = {\n    position: 'absolute',\n    top: 0,\n  }\n\n  getHeaderProps.push(header => {\n    return {\n      style: {\n        ...cellStyles,\n        left: `${header.totalLeft}px`,\n        width: `${header.totalWidth}px`,\n      },\n    }\n  })\n\n  getCellProps.push(cell => {\n    return {\n      style: {\n        ...cellStyles,\n        left: `${cell.column.totalLeft}px`,\n        width: `${cell.column.totalWidth}px`,\n      },\n    }\n  })\n\n  return instance\n}\n","import PropTypes from 'prop-types'\n\nconst propTypes = {}\n\nexport const useBlockLayout = hooks => {\n  hooks.useMain.push(useMain)\n}\n\nuseBlockLayout.pluginName = 'useBlockLayout'\n\nconst useMain = instance => {\n  PropTypes.checkPropTypes(propTypes, instance, 'property', 'useBlockLayout')\n\n  const {\n    totalColumnsWidth,\n    hooks: { getRowProps, getHeaderGroupProps, getHeaderProps, getCellProps },\n  } = instance\n\n  const rowStyles = {\n    style: {\n      display: 'flex',\n      width: `${totalColumnsWidth}px`,\n    },\n  }\n\n  getRowProps.push(() => rowStyles)\n  getHeaderGroupProps.push(() => rowStyles)\n\n  const cellStyles = {\n    display: 'inline-block',\n    boxSizing: 'border-box',\n  }\n\n  getHeaderProps.push(header => {\n    return {\n      style: {\n        ...cellStyles,\n        width: `${header.totalWidth}px`,\n      },\n    }\n  })\n\n  getCellProps.push(cell => {\n    return {\n      style: {\n        ...cellStyles,\n        width: `${cell.column.totalWidth}px`,\n      },\n    }\n  })\n\n  return instance\n}\n"],"names":["defaultColumn","Cell","cell","value","String","show","width","minWidth","maxWidth","Number","MAX_SAFE_INTEGER","safeUseLayoutEffect","window","process","env","NODE_ENV","React","useLayoutEffect","useEffect","findMaxDepth","columns","depth","reduce","prev","curr","Math","max","decorateColumn","column","userDefaultColumn","parent","index","id","accessor","Header","accessorPath","split","row","getBy","console","error","Error","decorateColumnTree","map","columnIndex","makeHeaderGroups","flatColumns","headerGroups","buildGroup","headerGroup","headers","parentColumns","hasParents","some","col","forEach","isFirst","length","latestParentColumn","reverse","similarParentColumns","filter","d","originalID","push","join","placeholderColumn","placeholderOf","includes","totalHeaderCount","sum","header","determineHeaderVisibility","instance","totalVisibleHeaderCount","subHeader","handleColumn","parentVisible","isVisible","subColumn","obj","path","def","val","pathObj","makePathArray","cursor","pathPart","e","defaultOrderByFn","arr","funcs","dirs","_toConsumableArray","sort","rowA","rowB","i","sortFn","desc","sortInt","getFirstDefined","args","defaultGroupByFn","rows","columnID","resKey","values","Array","isArray","getElementDimensions","element","rect","getBoundingClientRect","style","getComputedStyle","margins","left","parseInt","marginLeft","right","marginRight","padding","paddingLeft","paddingRight","ceil","outerWidth","scrollWidth","flexRender","Comp","props","isReactComponent","isClassComponent","component","proto","Object","getPrototypeOf","prototype","isFunctionComponent","mergeProps","groups","className","rest","Boolean","applyHooks","hooks","initial","next","nextValue","applyPropHooks","warnUnknownProps","keys","JSON","stringify","isFunction","a","flattenBy","childKey","recurse","ensurePluginOrder","plugins","befores","pluginName","afters","pluginIndex","findIndex","plugin","before","beforeIndex","after","afterIndex","expandRows","manualExpandedKey","expanded","expandSubRows","expandedRows","handleRow","key","isExpanded","original","canExpand","subRows","flattenDeep","replace","newArr","propTypes","data","PropTypes","array","isRequired","arrayOf","object","getSubRows","func","getRowID","debug","bool","renderErr","defaultState","defaultInitialState","defaultColumnInstance","defaultReducer","old","newState","defaultGetSubRows","defaultGetRowID","useTable","checkPropTypes","userColumns","initialState","userState","state","reducer","useState","originalState","originalSetState","useMemo","setState","useCallback","updater","type","instanceRef","useRef","assign","current","columnsBeforeHeaderGroups","columnsBeforeHeaderGroupsDeps","useBeforeDimensions","useMain","useRows","prepareRow","getTableProps","getTableBodyProps","getRowProps","getHeaderGroupProps","getHeaderProps","getCellProps","time","timeEnd","newColumns","flatRows","accessedData","accessRow","originalRow","parentPath","rowID","cells","unpreparedAccessWarning","undefined","flatHeaders","all","calculateDimensions","render","userProps","colSpan","columnPathStr","totalColumnsWidth","calculateHeaderWidths","sumTotalWidth","subHeaders","totalLeft","totalWidth","min","actions","addActions","acts","action","string","paginateExpandedRows","useExpanded","getExpandedToggleProps","toggleExpandedByPath","set","exists","shouldExist","newExpanded","Set","add","delete","toggleExpanded","propsFromHooks","onClick","persist","title","info","expandedDepth","findExpandedDepth","maxDepth","text","filterValue","rowValue","toLowerCase","autoRemove","exactText","exactTextCase","includesAll","every","exact","equals","between","Infinity","temp","filters","shape","disableFilters","Filter","any","manualFilters","useFilters","userFilterTypes","filterTypes","preFilteredRows","preFilteredFlatRows","setFilter","find","filterMethod","getFilterMethod","newFilter","shouldAutoRemove","columnDisableFilters","canFilter","filteredRows","filteredFlatRows","filterRows","entries","filteredSoFar","warn","setAllFilters","newFilters","average","round","median","uniqueCount","size","count","groupBy","aggregate","oneOfType","disableGrouping","Aggregated","groupByFn","manualGrouping","aggregations","useGroupBy","getGroupByToggleProps","deps","groupByColumns","g","nonGroupByColumns","groupByBoundaryColumnIndex","groupByBoundary","slice","manualGroupBy","userAggregations","columnDisableGrouping","isGrouped","groupedIndex","indexOf","canGroupBy","toggleGroupBy","toggle","groupByTogglePropsFromHooks","groupByID","isRepeatedValue","isAggregated","groupedRows","aggregateRowsToValues","isSourceRows","columnValues","aggregator","aggregateFn","groupRecursively","groupByVal","preGroupedRows","reSplitAlphaNumeric","alphanumeric","getRowValueByColumnID","b","toString","aa","shift","bb","an","bn","combo","isNaN","datetime","compareBasic","getTime","basic","sortBy","sortType","sortDescFirst","disableSorting","orderByFn","sortTypes","manualSorting","disableMultiSort","isMultiSortEvent","maxMultiSortColCount","number","disableSortRemove","disableMultiRemove","useSortBy","getSortByToggleProps","userSortTypes","shiftKey","toggleSortBy","multi","existingSortBy","existingIndex","hasDescDefined","newSortBy","splice","sortByChange","columnDisableSorting","canSort","clearSorting","sortByTogglePropsFromHooks","columnSort","isSorted","sortedIndex","isSortedDesc","sortedRows","availableSortBy","sortData","sortedData","sortMethod","sortInverted","preSortedRows","pageSize","pageIndex","manualPagination","usePagination","disablePageResetOnDataChange","userPageCount","pageCount","rowDep","isPageIndexMountedRef","disablePageResetOnDataChangeRef","pageChange","pageOptions","page","pageStart","pageEnd","canPreviousPage","canNextPage","gotoPage","newPageIndex","previousPage","nextPage","setPageSize","topRowIndex","floor","pageSizeChange","selectedRowPaths","manualRowSelectedKey","useRowSelect","getToggleRowSelectedProps","getToggleAllRowsSelectedProps","selectedFlatRows","subRowPaths","isSelected","disableSelectedRowsResetOnDataChange","flatRowPaths","isAllRowsSelected","isRowSelectedMountedRef","disableSelectedRowsResetOnDataChangeRef","toggleRowSelectedAll","toggleRowSelected","childRowPrefixKey","newSelectedRows","rowPath","startsWith","updateParentRow","parentKey","has","toggleAllRowsSelectedPropsFromHooks","toggleRowSelectedPropsFromHooks","checked","onChange","target","rowState","initialRowStateAccessor","useRowState","setRowState","pathKey","setCellState","cellState","rowsMountedRef","columnOrder","useColumnOrder","columnOrderCopy","columnsCopy","columnsInOrder","targetColumnID","foundIndex","setColumnOrder","columnResizing","columnWidths","canResize","useResizeColumns","getResizerProps","disableResizing","position","isResizing","isResizingColumn","resizerPropsFromHooks","onMouseDown","headersToResize","getLeafHeaders","startWidths","startX","clientX","onMouseMove","percentageDeltaX","newColumnWidths","document","addEventListener","onMouseUp","removeEventListener","draggable","leafHeaders","recurseHeader","useAbsoluteLayout","rowStyles","cellStyles","top","useBlockLayout","display","boxSizing"],"mappings":"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"}